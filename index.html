<!DOCTYPE html>
<html>
<head>
    <title>Snake Game</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1 id="explain">¬°Bienvenid@ a snake! (Welcome to snake!)</h1>
    <p id="explain">Usa las flechas del teclado, el wasd o los botones para moverte(Use the arrows or the buttons to move)</p>
    <button id="start" onclick="init()">Start</button>
    <canvas id="gameCanvas" width="400" height="400"></canvas>

    <div id="gameControls">
        <button id="upButton" onclick="moveUp()">Up‚¨ÜÔ∏è</button>
        <button id="downButton" onclick="moveDown()">Down‚¨áÔ∏è</button>
        <button id="leftButton" onclick="moveLeft()">Left‚¨ÖÔ∏è</button>
        <button id="rightButton" onclick="moveRight()">Right‚û°Ô∏è</button>
    </div>
    <footer>
        <div id="progreso">
            <button id="link1" onclick="redireccionar()"></button>
            <p>Progreso</p>
        </div>
        <div id="mejores">
            <button id="link2" onclick="redireccionar2()"></button>
            <p>Mejores puntuaciones</p>
        </div>
    </footer>
      
    <script>
        // Crear un elemento de audio
        var audioElement = document.createElement("audio");
        audioElement.src = "snakechomp.mp3";
        var audioElement2 = document.createElement("audio");
        audioElement2.src = "snakedeath.mp3";
        var audioElement3 = document.createElement("audio");
        audioElement3.src = "win.mp3";
        
        const canvas = document.getElementById("gameCanvas");
        const context = canvas.getContext("2d");
        // Configuraci√≥n del juego
        const gridSize = 20;
        const canvasSize = 400;
        const initialSnakeSize = 3;
        const moveInterval = 100;

        let snake = [];
        let direction;
        let food;
        let gameLoop;
        let score = 0;

        //Ganar la partida  
        function win(){
            audioElement3.play();
            clearInterval(gameLoop);
            updateHighScore();
            alert("You got the max score!!! ü•≥ü•≥ü•≥ü•≥");  
        }


        // Moverse
        function moveUp() {
          if (direction !== "down") {
            direction = "up";
          }
        }

        function moveDown() {
          if (direction !== "up") {
            direction = "down";
          }
        }

        function moveLeft() {
          if (direction !== "right") {
            direction = "left";
          }
        }

        function moveRight() {
          if (direction !== "left") {
            direction = "right";
          }
        }

        // Inicializar el juego
        function init() {
            direction = "right";
            snake = [];
            score = 0;
            createSnake();
            createFood();

            // Incrementar la cantidad de veces jugadas y guardarla en el localStorage
            let jugadas = localStorage.getItem("snakeJugadas");
            if (jugadas === null || isNaN(jugadas)) {
                jugadas = 0; // Si no existe o no es v√°lida, establecer la cantidad de veces jugadas inicial como 0
            } else {
                jugadas = parseInt(jugadas); // Convertir la cantidad de veces jugadas en un n√∫mero entero
            }
            jugadas++;
            localStorage.setItem("snakeJugadas", jugadas);

            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, moveInterval);
        }

        // Crear la serpiente inicial
        function createSnake() {
            for (let i = initialSnakeSize - 1; i >= 0; i--) {
                snake.push({ x: i, y: 0 });
            }
        }

        // Crear la comida
        function createFood() {
            const maxPos = gridSize - 1;
            let validPos = false;

            while (!validPos) {
                const xPos = Math.floor(Math.random() * gridSize);
                const yPos = Math.floor(Math.random() * gridSize);

                validPos = true;

                for (let i = 0; i < snake.length; i++) {
                    if (snake[i].x === xPos && snake[i].y === yPos) {
                        validPos = false;
                        break;
                    }
                }

                if (validPos) {
                    food = { x: xPos, y: yPos };
                }
            }
        }

        // Actualizar el estado del juego en cada iteraci√≥n
        function update() {
            const head = { x: snake[0].x, y: snake[0].y };
            switch (direction) {
                case "right":
                    head.x++;
                    break;
                case "left":
                    head.x--;
                    break;
                case "up":
                    head.y--;
                    break;
                case "down":
                    head.y++;
                    break;
            }

            // Verificar colisiones
            if (checkCollisionWithBorder(head) || checkCollisionWithSelf(head)) {
                gameOver();
                return;
            }

            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                // La serpiente come la comida y aumenta de longitud
                score++;
                audioElement.play();
                createFood();
            } else {
                snake.pop();
            }

            draw();
            drawScore();
            //Verificar si se alcanz√≥ el puntaje m√°ximo
            if(score === 398){
                win();
            }
        }

        // Verificar si la serpiente colisiona con los bordes del canvas
        function checkCollisionWithBorder(head) {
            return (
                head.x < 0 ||
                head.x >= gridSize ||
                head.y < 0 ||
                head.y >= gridSize
            );
            
        }

        // Verificar si la serpiente colisiona consigo misma
        function checkCollisionWithSelf(head) {
            for (let i = 1; i < snake.length; i++) {
                if (snake[i].x === head.x && snake[i].y === head.y) {
                    return true;
                }
            }
            return false;
        }

        // Dibujar el juego en el canvas
        function draw() {
            context.clearRect(0, 0, canvasSize, canvasSize);

            for (let i = 0; i < snake.length; i++) {
                drawSnakePart(snake[i].x, snake[i].y);
            }

            drawFood(food.x, food.y);
        }

        // Dibujar una parte de la serpiente
        function drawSnakePart(x, y) {
            const eyeSize = gridSize / 3; // Tama√±o del ojo en relaci√≥n al tama√±o de la cuadr√≠cula
            const eyeOffsetX = gridSize / 3; // Desplazamiento horizontal del ojo
            const eyeOffsetY = gridSize / 3; // Desplazamiento vertical del ojo
            const pupilSize = eyeSize / 2; // Tama√±o de la pupila en relaci√≥n al tama√±o del ojo

            context.fillStyle = "rgb(0,86,6)";
            context.fillRect(
                x * gridSize,
                y * gridSize,
                gridSize,
                gridSize
            );

            // Dibujar el ojo solo en la cabeza de la serpiente
            if (x === snake[0].x && y === snake[0].y) {
                context.fillStyle = "#fff"; // Color del ojo (blanco)
                context.fillRect(
                    x * gridSize + eyeOffsetX,
                    y * gridSize + eyeOffsetY,
                    eyeSize,
                    eyeSize
                );

                const headX = x * gridSize + eyeOffsetX + eyeSize / 2; // Posici√≥n x del centro del ojo
                const headY = y * gridSize + eyeOffsetY + eyeSize / 2; // Posici√≥n y del centro del ojo

                const dx = food.x * gridSize + gridSize / 2 - headX; // Distancia horizontal entre la cabeza y la manzana
                const dy = food.y * gridSize + gridSize / 2 - headY; // Distancia vertical entre la cabeza y la manzana

                const angle = Math.atan2(dy, dx); // Calcular el √°ngulo entre la cabeza y la manzana

                const pupilRadius = pupilSize / 2; // Radio de la pupila
                const pupilOffsetX = eyeOffsetX + eyeSize / 2 + Math.cos(angle) * (eyeSize / 2 - pupilRadius - 1); // Desplazamiento horizontal de la pupila
                const pupilOffsetY = eyeOffsetY + eyeSize / 2 + Math.sin(angle) * (eyeSize / 2 - pupilRadius); // Desplazamiento vertical de la pupila

                context.fillStyle = "#000"; // Color de la pupila (negro)
                context.beginPath();
                context.arc(
                    x * gridSize + pupilOffsetX,
                    y * gridSize + pupilOffsetY,
                    pupilRadius,
                    0,
                    Math.PI * 2
                );
                context.fill();}
            }




        // Dibujar la comida
        function drawFood(x, y) {
            context.fillStyle = "#f00";
            context.fillRect(
                x * gridSize,
                y * gridSize,
                gridSize,
                gridSize
            );
        }

        // Dibujar la puntuaci√≥n y el r√©cord
        function drawScore() {
            context.fillStyle = "#000";
            context.font = "16px Arial";
            context.fillText("Puntaje(Score): " + score , 10, 20);
            context.fillText("R√©cord(High Score): " + highScore, 10, 40);
        }


        // Controlar la direcci√≥n de la serpiente
        document.addEventListener("keydown", function (event) {
            const key = event.keyCode;

            switch (key) {
                case 37:
                    if (direction !== "right") direction = "left";
                    break;
                
                case 65:
                if (direction !== "right") direction = "left";
                break;
                    
                case 38:
                if (direction !== "down") direction = "up";
                break;
                
                case 87:
                if (direction !== "down") direction = "up";
                break;
                
                case 39:
                    if (direction !== "left") direction = "right";
                    break;

                case 68:
                if (direction !== "left") direction = "right";
                break;
                    
                case 40:
                    if (direction !== "up") direction = "down";
                    break;

                case 83:
                if (direction !== "up") direction = "down";
                break;
            }
        });

        // Obtener el r√©cord almacenado en el localStorage
        let highScore = localStorage.getItem("snakeHighScore");

        // Verificar si el r√©cord existe y es v√°lido
        if (highScore === null || isNaN(highScore)) {
            highScore = 0; // Si no existe o no es v√°lido, establecer el r√©cord inicial como 0
        } else {
            highScore = parseInt(highScore); // Convertir el r√©cord en un n√∫mero entero
        }

        // Funci√≥n para actualizar el r√©cord
        function updateHighScore() {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem("snakeHighScore", highScore); // Guardar el nuevo r√©cord en el localStorage
            }
        }

        // En la funci√≥n gameOver(), llamar a updateHighScore() para actualizar el r√©cord
        function gameOver() {
            audioElement2.play();
            clearInterval(gameLoop);
            updateHighScore();
            alert("Game Over. Your score: " + score + ". High Score: " + highScore);
        }
    </script>
    <script src="script.js"></script>
</body>
</html>
